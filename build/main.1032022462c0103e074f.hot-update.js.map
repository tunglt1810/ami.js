{"version":3,"sources":["webpack://AMI/./src/loaders/loaders.cornerstone.js"],"names":["PAKO","require","LoadersVolumesCornerstone","loadSequenceGroup","url","requests","window","console","log","fetchSequence","forEach","push","fetch","file","Promise","all","then","parse","rawdata","_data","data","catch","error","loadSequence","cornerstone","loadAndCacheImage","image","response","emit","time","Date","_progressBar","update","resolve","reject","setTimeout","Array","isArray","_preprocess","dataset","length","mhdFile","filter","_filterByExtension","bind","rawFile","extension","mhdBuffer","buffer","rawBuffer","Parser","_parser","filename","volumeParser","e","warn","series","ModelsSeries","rawHeader","seriesInstanceUID","transferSyntaxUID","seriesDate","seriesDescription","studyDate","studyDescription","numberOfFrames","numberOfChannels","modality","segmentationType","segmentationSegments","patientID","patientName","patientAge","patientBirthdate","patientSex","stack","ModelsStack","pixelRepresentation","pixelType","invert","spacingBetweenSlices","parseFrameClosure","i","dataParser","parseFrame","frame","ModelsFrame","sopInstanceUID","index","frameTime","ultrasoundRegions","rows","columns","pixelPaddingValue","pixelData","extractPixelData","pixelSpacing","sliceThickness","imageOrientation","rightHanded","imagePosition","dimensionIndexValues","bitsAllocated","instanceNumber","windowCenter","windowWidth","rescaleSlope","rescaleIntercept","minMax","minMaxPixelData","referencedSegmentNumber","_parsed","_totalParsed","total","parsed","toUpperCase","ParsersNifti","ParsersDicom","ParsersMhd","ParsersNrrd","ParsersMgh","parsedUrl","CoreUtils","parseUrl","pathname","query","gzcompressed","split","shift","pop","decompressedData","inflate","item","LoadersBase"],"mappings":"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","file":"main.1032022462c0103e074f.hot-update.js","sourcesContent":["/** * Imports ***/\nconst PAKO = require('pako');\n\nimport LoadersBase from './loaders.base';\nimport CoreUtils from '../core/core.utils';\nimport ModelsSeries from '../models/models.series';\nimport ModelsStack from '../models/models.stack';\nimport ModelsFrame from '../models/models.frame';\nimport ParsersDicom from '../parsers/parsers.dicom';\nimport ParsersMhd from '../parsers/parsers.mhd';\nimport ParsersNifti from '../parsers/parsers.nifti';\nimport ParsersNrrd from '../parsers/parsers.nrrd';\nimport ParsersMgh from '../parsers/parsers.mgh';\n\nimport cornerstone from 'cornerstone-core';\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @module loaders/volumes\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var lDicomoader = new dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     console.log(object);\n *   }\n * );\n */\nexport default class LoadersVolumesCornerstone extends LoadersBase {\n    loadSequenceGroup(url, requests) {\n        window.console.log('load sequence group');\n        const fetchSequence = [];\n\n        url.forEach(file => {\n            fetchSequence.push(this.fetch(file, requests));\n        });\n\n        return Promise.all(fetchSequence)\n            .then(rawdata => {\n                return this.parse(rawdata);\n            })\n            .then(data => {\n                this._data.push(data);\n                return data;\n            })\n            .catch(function (error) {\n                if (error === 'Aborted') {\n                    return;\n                }\n                window.console.log('oops... something went wrong...');\n                window.console.log(error);\n            });\n    }\n\n    loadSequence(url, requests) {\n        window.console.log('load sequence');\n        return cornerstone.loadAndCacheImage(url)\n            .then(image => {\n                window.console.log('loaded by cornerstone', image);\n            });\n    };\n\n    /**\n     * Parse response.\n     * response is formated as:\n     *    {\n     *      url: 'resource url',\n     *      buffer: xmlresponse,\n     *    }\n     * @param {object} response - response\n     * @return {promise} promise\n     */\n    parse(response) {\n        // emit 'parse-start' event\n        this.emit('parse-start', {\n            file: response.url,\n            time: new Date(),\n        });\n\n        // give a chance to the UI to update because\n        // after the rendering will be blocked with intensive JS\n        // will be removed after eventer set up\n        if (this._progressBar) {\n            this._progressBar.update(0, 100, 'parse', response.url);\n        }\n\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                resolve(\n                    new Promise((resolve, reject) => {\n                        let data = response;\n\n                        if (!Array.isArray(data)) {\n                            data = [data];\n                        }\n\n                        data.forEach(dataset => {\n                            this._preprocess(dataset);\n                        });\n\n                        if (data.length === 1) {\n                            data = data[0];\n                        } else {\n                            // if raw/mhd pair\n                            let mhdFile = data.filter(this._filterByExtension.bind(null, 'MHD'));\n                            let rawFile = data.filter(this._filterByExtension.bind(null, 'RAW'));\n                            if (data.length === 2 && mhdFile.length === 1 && rawFile.length === 1) {\n                                data.url = mhdFile[0].url;\n                                data.extension = mhdFile[0].extension;\n                                data.mhdBuffer = mhdFile[0].buffer;\n                                data.rawBuffer = rawFile[0].buffer;\n                            }\n                        }\n\n                        let Parser = this._parser(data.extension);\n                        if (!Parser) {\n                            // emit 'parse-error' event\n                            this.emit('parse-error', {\n                                file: response.url,\n                                time: new Date(),\n                                error: data.filename + 'can not be parsed.',\n                            });\n                            reject(data.filename + ' can not be parsed.');\n                        }\n\n                        // check extension\n                        let volumeParser = null;\n                        try {\n                            volumeParser = new Parser(data, 0);\n                        } catch (e) {\n                            console.warn(e);\n                            // emit 'parse-error' event\n                            this.emit('parse-error', {\n                                file: response.url,\n                                time: new Date(),\n                                error: e,\n                            });\n                            reject(e);\n                        }\n\n                        // create a series\n                        let series = new ModelsSeries();\n                        series.rawHeader = volumeParser.rawHeader();\n                        // global information\n                        series.seriesInstanceUID = volumeParser.seriesInstanceUID();\n                        series.transferSyntaxUID = volumeParser.transferSyntaxUID();\n                        series.seriesDate = volumeParser.seriesDate();\n                        series.seriesDescription = volumeParser.seriesDescription();\n                        series.studyDate = volumeParser.studyDate();\n                        series.studyDescription = volumeParser.studyDescription();\n                        series.numberOfFrames = volumeParser.numberOfFrames();\n                        if (!series.numberOfFrames) {\n                            series.numberOfFrames = 1;\n                        }\n                        series.numberOfChannels = volumeParser.numberOfChannels();\n                        series.modality = volumeParser.modality();\n                        // if it is a segmentation, attach extra information\n                        if (series.modality === 'SEG') {\n                            // colors\n                            // labels\n                            // etc.\n                            series.segmentationType = volumeParser.segmentationType();\n                            series.segmentationSegments = volumeParser.segmentationSegments();\n                        }\n                        // patient information\n                        series.patientID = volumeParser.patientID();\n                        series.patientName = volumeParser.patientName();\n                        series.patientAge = volumeParser.patientAge();\n                        series.patientBirthdate = volumeParser.patientBirthdate();\n                        series.patientSex = volumeParser.patientSex();\n\n                        // just create 1 dummy stack for now\n                        let stack = new ModelsStack();\n                        stack.numberOfChannels = volumeParser.numberOfChannels();\n                        stack.pixelRepresentation = volumeParser.pixelRepresentation();\n                        stack.pixelType = volumeParser.pixelType();\n                        stack.invert = volumeParser.invert();\n                        stack.spacingBetweenSlices = volumeParser.spacingBetweenSlices();\n                        stack.modality = series.modality;\n                        // if it is a segmentation, attach extra information\n                        if (stack.modality === 'SEG') {\n                            // colors\n                            // labels\n                            // etc.\n                            stack.segmentationType = series.segmentationType;\n                            stack.segmentationSegments = series.segmentationSegments;\n                        }\n                        series.stack.push(stack);\n                        // recursive call for each frame\n                        // better than for loop to be able\n                        // to update dom with \"progress\" callback\n                        setTimeout(\n                            this.parseFrameClosure(series, stack, response.url, 0, volumeParser, resolve, reject),\n                            0\n                        );\n                    })\n                );\n            }, 10);\n        });\n    }\n\n    parseFrameClosure(series, stack, url, i, dataParser, resolve, reject) {\n        return () => {\n            this.parseFrame(series, stack, url, i, dataParser, resolve, reject);\n        };\n    }\n\n    /**\n     * recursive parse frame\n     * @param {ModelsSeries} series - data series\n     * @param {ModelsStack} stack - data stack\n     * @param {string} url - resource url\n     * @param {number} i - frame index\n     * @param {parser} dataParser - selected parser\n     * @param {promise.resolve} resolve - promise resolve args\n     * @param {promise.reject} reject - promise reject args\n     */\n    parseFrame(series, stack, url, i, dataParser, resolve, reject) {\n        let frame = new ModelsFrame();\n        frame.sopInstanceUID = dataParser.sopInstanceUID(i);\n        frame.url = url;\n        frame.index = i;\n        frame.invert = stack.invert;\n        frame.frameTime = dataParser.frameTime(i);\n        frame.ultrasoundRegions = dataParser.ultrasoundRegions(i);\n        frame.rows = dataParser.rows(i);\n        frame.columns = dataParser.columns(i);\n        frame.numberOfChannels = stack.numberOfChannels;\n        frame.pixelPaddingValue = dataParser.pixelPaddingValue(i);\n        frame.pixelRepresentation = stack.pixelRepresentation;\n        frame.pixelType = stack.pixelType;\n        frame.pixelData = dataParser.extractPixelData(i);\n        frame.pixelSpacing = dataParser.pixelSpacing(i);\n        frame.spacingBetweenSlices = dataParser.spacingBetweenSlices(i);\n        frame.sliceThickness = dataParser.sliceThickness(i);\n        frame.imageOrientation = dataParser.imageOrientation(i);\n        frame.rightHanded = dataParser.rightHanded();\n        stack.rightHanded = frame.rightHanded;\n        if (frame.imageOrientation === null) {\n            frame.imageOrientation = [1, 0, 0, 0, 1, 0];\n        }\n        frame.imagePosition = dataParser.imagePosition(i);\n        /*\n        null ImagePosition should not be handle here\n        if (frame.imagePosition === null) {\n          frame.imagePosition = [0, 0, i];\n        }*/\n        frame.dimensionIndexValues = dataParser.dimensionIndexValues(i);\n        frame.bitsAllocated = dataParser.bitsAllocated(i);\n        frame.instanceNumber = dataParser.instanceNumber(i);\n        frame.windowCenter = dataParser.windowCenter(i);\n        frame.windowWidth = dataParser.windowWidth(i);\n        frame.rescaleSlope = dataParser.rescaleSlope(i);\n        frame.rescaleIntercept = dataParser.rescaleIntercept(i);\n        // should pass frame index for consistency...\n        frame.minMax = dataParser.minMaxPixelData(frame.pixelData);\n\n        // if series.mo\n        if (series.modality === 'SEG') {\n            frame.referencedSegmentNumber = dataParser.referencedSegmentNumber(i);\n        }\n\n        stack.frame.push(frame);\n\n        // update status\n        this._parsed = i + 1;\n        this._totalParsed = series.numberOfFrames;\n\n        // will be removed after eventer set up\n        if (this._progressBar) {\n            this._progressBar.update(this._parsed, this._totalParsed, 'parse', url);\n        }\n\n        // emit 'parsing' event\n        this.emit('parsing', {\n            file: url,\n            total: this._totalParsed,\n            parsed: this._parsed,\n            time: new Date(),\n        });\n\n        if (this._parsed === this._totalParsed) {\n            // emit 'parse-success' event\n            this.emit('parse-success', {\n                file: url,\n                total: this._totalParsed,\n                parsed: this._parsed,\n                time: new Date(),\n            });\n\n            resolve(series);\n        } else {\n            setTimeout(\n                this.parseFrameClosure(series, stack, url, this._parsed, dataParser, resolve, reject),\n                0\n            );\n        }\n    }\n\n    /**\n     * Return parser given an extension\n     * @param {string} extension - extension\n     * @return {parser} selected parser\n     */\n    _parser(extension) {\n        let Parser = null;\n\n        switch (extension.toUpperCase()) {\n            case 'NII':\n            case 'NII_':\n                Parser = ParsersNifti;\n                break;\n            case 'DCM':\n            case 'DIC':\n            case 'DICOM':\n            case 'IMA':\n            case '':\n                Parser = ParsersDicom;\n                break;\n            case 'MHD':\n                Parser = ParsersMhd;\n                break;\n            case 'NRRD':\n                Parser = ParsersNrrd;\n                break;\n            case 'MGH':\n            case 'MGZ':\n                Parser = ParsersMgh;\n                break;\n            default:\n                console.warn('unsupported extension: ' + extension);\n                return false;\n        }\n        return Parser;\n    }\n\n    /**\n     * Pre-process data to be parsed (find data type and de-compress)\n     * @param {*} data\n     */\n    _preprocess(data) {\n        const parsedUrl = CoreUtils.parseUrl(data.url);\n        // update data\n        data.filename = parsedUrl.filename;\n        data.extension = parsedUrl.extension;\n        data.pathname = parsedUrl.pathname;\n        data.query = parsedUrl.query;\n\n        // unzip if extension is '.gz'\n        if (data.extension === 'gz') {\n            data.gzcompressed = true;\n            data.extension = data.filename\n                .split('.gz')\n                .shift()\n                .split('.')\n                .pop();\n        } else if (data.extension === 'mgz') {\n            data.gzcompressed = true;\n            data.extension = 'mgh';\n        } else if (data.extension === 'zraw') {\n            data.gzcompressed = true;\n            data.extension = 'raw';\n        } else {\n            data.gzcompressed = false;\n        }\n\n        if (data.gzcompressed) {\n            let decompressedData = PAKO.inflate(data.buffer);\n            data.buffer = decompressedData.buffer;\n        }\n    }\n\n    /**\n     * Filter data by extension\n     * @param {*} extension\n     * @param {*} item\n     * @returns Boolean\n     */\n    _filterByExtension(extension, item) {\n        if (item.extension.toUpperCase() === extension.toUpperCase()) {\n            return true;\n        }\n        return false;\n    }\n}\n"],"sourceRoot":""}